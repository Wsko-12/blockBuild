<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>all game blocks</title>
    <link rel="stylesheet" href="styles/common.css">

    <link rel="stylesheet" href="styles/gameInterface.css">
  </head>
  <body style="position:fixed;width:100vw;height:100vh;margin:0">
    <section id="render" class="fullscreen">

    </section>

  </body>
  <script type="module">
    import * as THREE from './ThreeJsLib/build/three.module.js';
    import {MAIN} from './scripts/main.js';
    import {TEXTURES_BASE} from './scripts/modules/bases/textures_base.js';
    import {MESHES_BASE} from './scripts/modules/bases/meshes_base.js';
    import {BLOCKS_BASE} from './scripts/modules/bases/blocks_base.js';
    import {OrbitControls} from './ThreeJsLib/examples/jsm/controls/OrbitControls.js';
    MAIN.render.init();

    TEXTURES_BASE.init().then(result => {
      MESHES_BASE.init();
      BLOCKS_BASE.init();
      // const canvas = document.querySelector('#canvas');
      // const ctx = canvas.getContext('2d');
      // ctx.imageSmoothingEnabled = false;
      // ctx.filter = 'opacity(100%)';
      // ctx.drawImage(MESHES_BASE.oak_leaves.M[0].map.image,0,0,16,16);


      const geomJSON =     {
            "metadata": {
              "version": 4.5,
              "type": "BufferGeometry",
              "generator": "BufferGeometry.toJSON"
            },
            "uuid": "67E7D0B7-E734-4974-BC2F-515D6E28191E",
            "type": "BufferGeometry",
            "data": {
              "attributes": {
                "position": {
                  "itemSize": 3,
                  "type": "Float32Array",
                  "array": [
                    //blender
                    //n
                    -0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,
                    -0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,

                    //w
                    -0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,
                    -0.5,0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,

                    //s
                    0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,
                    0.5,0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,

                    //e
                    0.5,0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,0.5,
                    0.5,0.5,-0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,

                    //t
                    -0.5,0.5,-0.5,0.5,0.5,0.5,0.5,0.5,-0.5,
                    -0.5,0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,0.5,

                    //b
                    0.5,-0.5,-0.5,0.5,-0.5,0.5,-0.5,-0.5,0.5,
                    0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5

                    //me
                    // //e
                    // 0.5,0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,0.5,
                    // 0.5,0.5,-0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,
                    //
                    // //w
                    // -0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,
                    // -0.5,0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,
                    //
                    //
                    // //t
                    // -0.5,0.5,-0.5,0.5,0.5,0.5,0.5,0.5,-0.5,
                    // -0.5,0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,0.5,
                    //
                    //
                    // //b
                    // 0.5,-0.5,-0.5,0.5,-0.5,0.5,-0.5,-0.5,0.5,
                    // 0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5,
                    //
                    //
                    // //s
                    // 0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,
                    // 0.5,0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,
                    //
                    // //n
                    // -0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,
                    // -0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,

                  ],
                  "normalized": false
                },
                "normal": {
                  "itemSize": 3,
                  "type": "Float32Array",
                  "array": [0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0],
                  "normalized": false
                },
                "uv": {
                  "itemSize": 2,
                  "type": "Float32Array",
                  "array": [1.0,0,0,0,0,1.0,1.0,0,0,1.0,1.0,1.0,1.0,0,0,0,0,1.0,1.0,0,0,1.0,1.0,1.0,0,1.0,1.0,1.0,1.0,0,0,1.0,1.0,0,0,0,0,1.0,1.0,1.0,1.0,0,0,1.0,1.0,0,0,0,1.0,1.0,0,0,0,1.0,1.0,1.0,1.0,0,0,0,1.0,1.0,1.0,0,0,0,1.0,1.0,0,0,0,1.0],
                  "normalized": false
                }
              },
              "index": {
                "type": "Uint16Array",
                "array": [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35]
              },
              "boundingSphere": {
                "center": [0,0,0],
                "radius": 0.8660254037844386
              }
            }
          }



          const loader = new THREE.BufferGeometryLoader();


          // const BOXgeometry =  loader.parse(geomJSON);

          const geometry = loader.parse(geomJSON);
          const material = new THREE.MeshBasicMaterial({map:MESHES_BASE.getMesh('grass').material[2].map});


          const facesAttributeArr = new Float32Array([
            //blender
            1.0,1.0,1.0,1.0,1.0,1.0,//n

            1.0,1.0,1.0,1.0,1.0,1.0,//w

            1.0,1.0,1.0,1.0,1.0,1.0,//s

            1.0,1.0,1.0,1.0,1.0,1.0,//e

            0.0,0.0,0.0,0.0,0.0,0.0,//t

            1.0,1.0,1.0, 1.0,1.0,1.0,//b


            //me
            // 1.0,1.0,1.0, 1.0,1.0,1.0,//e
            //
            // 1.0,1.0,1.0, 1.0,1.0,1.0,//w
            //
            // 1.0,1.0,1.0,1.0,1.0,1.0,//t
            //
            // 1.0,1.0,1.0,1.0,1.0,1.0,//b
            //
            // 1.0,1.0,1.0,1.0,1.0,1.0,//s
            //
            //
            // 1.0,1.0,1.0, 1.0,1.0,1.0,//n
          ]);

          geometry.setAttribute('faceHiding',new THREE.BufferAttribute( facesAttributeArr, 1 ));


          const vertexShader = `
            #include <common>
            #include <uv_pars_vertex>
            #include <uv2_pars_vertex>
            #include <envmap_pars_vertex>
            #include <color_pars_vertex>
            #include <fog_pars_vertex>
            #include <morphtarget_pars_vertex>
            #include <skinning_pars_vertex>
            #include <logdepthbuf_pars_vertex>
            #include <clipping_planes_pars_vertex>
            attribute  float faceHiding;
            varying float faceHide;
            void main() {
                  faceHide = faceHiding;
                	#include <uv_vertex>
                	#include <uv2_vertex>
                	#include <color_vertex>
                	#include <skinbase_vertex>
                	#ifdef USE_ENVMAP
                	#include <beginnormal_vertex>
                	#include <morphnormal_vertex>
                	#include <skinnormal_vertex>
                	#include <defaultnormal_vertex>
                	#endif
                	#include <begin_vertex>
                	#include <morphtarget_vertex>
                	#include <skinning_vertex>
                	#include <project_vertex>
                	#include <logdepthbuf_vertex>
                	#include <worldpos_vertex>
                	#include <clipping_planes_vertex>
                	#include <envmap_vertex>
                	#include <fog_vertex>
            }`


          const fragmentShader = `
              uniform vec3 diffuse;
              uniform float opacity;
              #ifndef FLAT_SHADED
              varying vec3 vNormal;
              #endif
              #include <common>
              #include <dithering_pars_fragment>
              #include <color_pars_fragment>
              #include <uv_pars_fragment>
              #include <uv2_pars_fragment>
              #include <map_pars_fragment>
              #include <alphamap_pars_fragment>
              #include <aomap_pars_fragment>
              #include <lightmap_pars_fragment>
              #include <envmap_common_pars_fragment>
              #include <envmap_pars_fragment>
              #include <cube_uv_reflection_fragment>
              #include <fog_pars_fragment>
              #include <specularmap_pars_fragment>
              #include <logdepthbuf_pars_fragment>
              #include <clipping_planes_pars_fragment>
              varying float faceHide;
              void main() {
                    if(faceHide == 0.0){
                      discard;
                    }
                    #include <clipping_planes_fragment>
                    vec4 diffuseColor = vec4( diffuse, opacity );
                    #include <logdepthbuf_fragment>
                    #include <map_fragment>
                    #include <color_fragment>
                    #include <alphamap_fragment>
                    #include <alphatest_fragment>
                    #include <specularmap_fragment>
                    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
                    #ifdef USE_LIGHTMAP

                      vec4 lightMapTexel= texture2D( lightMap, vUv2 );
                      reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
                    #else
                      reflectedLight.indirectDiffuse += vec3( 1.0 );
                    #endif
                    #include <aomap_fragment>
                    reflectedLight.indirectDiffuse *= diffuseColor.rgb;
                    vec3 outgoingLight = reflectedLight.indirectDiffuse;
                    #include <envmap_fragment>
                    gl_FragColor = vec4( outgoingLight, diffuseColor.a );
                    #include <tonemapping_fragment>
                    #include <encodings_fragment>
                    #include <fog_fragment>
                    #include <premultiplied_alpha_fragment>
                    #include <dithering_fragment>
              }`





            material.onBeforeCompile = function(shader){
              shader.vertexShader=vertexShader;
              shader.fragmentShader=fragmentShader;
            }






          const mesh = new THREE.Mesh(geometry,material);



          const mesh_test = MESHES_BASE.getMesh('test');
          mesh_test.position.set(0,2,0)
          MAIN.render.scene.add(mesh_test);









          MAIN.render.scene.add(mesh);






      const controls = new OrbitControls( MAIN.render.camera, MAIN.render.renderer.domElement );
      MAIN.render.camera.position.set(10,10,10)
      MAIN.render.camera.lookAt(0,0,0);

      MAIN.render.render();

    });





  </script>
</html>
