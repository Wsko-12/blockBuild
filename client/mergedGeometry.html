<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>all game blocks</title>
    <link rel="stylesheet" href="styles/common.css">

    <link rel="stylesheet" href="styles/gameInterface.css">
  </head>
  <body style="position:fixed;width:100vw;height:100vh;margin:0">
    <section id="render" class="fullscreen">

    </section>
    <!-- <canvas id="canvas" style="position:fixed;left:50vw;border:1px solid black" width="16" height="16"></canvas> -->

  </body>
  <script type="module">
    import * as THREE from './ThreeJsLib/build/three.module.js';
    import {MAIN} from './scripts/main.js';
    import {TEXTURES_BASE} from './scripts/modules/bases/textures_base.js';
    import {MESHES_BASE} from './scripts/modules/bases/meshes_base.js';
    import {BLOCKS_BASE} from './scripts/modules/bases/blocks_base.js';
    import {OrbitControls} from './ThreeJsLib/examples/jsm/controls/OrbitControls.js';
    import { BufferGeometryUtils } from './ThreeJsLib/examples/jsm/utils/BufferGeometryUtils.js';



    const geomJSON =     {
        	"metadata": {
        		"version": 4.5,
        		"type": "BufferGeometry",
        		"generator": "BufferGeometry.toJSON"
        	},
        	"uuid": "67E7D0B7-E734-4974-BC2F-515D6E28191E",
        	"type": "BufferGeometry",
        	"data": {
        		"attributes": {
        			"position": {
        				"itemSize": 3,
        				"type": "Float32Array",
        				"array": [-0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,0.5,-0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,-0.5,0.5,-0.5,0.5,0.5,0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5],
        				"normalized": false
        			},
        			"normal": {
        				"itemSize": 3,
        				"type": "Float32Array",
        				"array": [0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0],
        				"normalized": false
        			},
        			"uv": {
        				"itemSize": 2,
        				"type": "Float32Array",
        				"array": [1.0,0,0,0,0,1.0,1.0,0,0,1.0,1.0,1.0,1.0,0,0,0,0,1.0,1.0,0,0,1.0,1.0,1.0,0,1.0,1.0,1.0,1.0,0,0,1.0,1.0,0,0,0,0,1.0,1.0,1.0,1.0,0,0,1.0,1.0,0,0,0,1.0,1.0,0,0,0,1.0,1.0,1.0,1.0,0,0,0,1.0,1.0,1.0,0,0,0,1.0,1.0,0,0,0,1.0],
        				"normalized": false
        			}
        		},
        		"index": {
        			"type": "Uint16Array",
        			"array": [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35]
        		},
        		"boundingSphere": {
        			"center": [0,0,0],
        			"radius": 0.8660254037844386
        		}
        	}
        }





const loader = new THREE.BufferGeometryLoader();


const BOXgeometry =  loader.parse(geomJSON);



    MAIN.render.init();

    TEXTURES_BASE.init().then(result => {
      MESHES_BASE.init();
      BLOCKS_BASE.init();


      // for(let x = 0;x<100;x++){
      //    for(let z = 0;z<100;z++){
      //      const mesh_1 = MESHES_BASE.getMesh('ground');
      //      mesh_1.position.set(x,0,z);
      //      MAIN.render.scene.add(mesh_1)
      //    };
      //  };
      // const mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1),MESHES_BASE.getMesh('grass').material[0])
      //  MAIN.render.scene.add(mesh);
      //



       // merged
      const geometries = [];
      const meshes = []

      let startIndex = 0;
      let countIndex = 0;
      for(let x = 0;x<256;x++){
        for(let z = 0;z<256;z++){
          if(z === 5 && x=== 5){
          //
          }else{
            const geometry = loader.parse(geomJSON);
            const mesh_1 = new THREE.Mesh(geometry,MESHES_BASE.getMesh('grass').material[0])
            meshes.push(mesh_1);
            mesh_1.geometry.translate(x+0.5,0.5,z+0.5);

            geometries.push(mesh_1.geometry.clone());
          };
        };
      };






			const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries( geometries,true );
      const chunk = new THREE.Mesh( mergedGeometry, new THREE.MeshBasicMaterial({map:MESHES_BASE.getMesh('grass').material[0].map}));
      // console.log(chunk)
    	 MAIN.render.scene.add(chunk);



       

       document.body.addEventListener('click',function(e){
           const raycaster = new THREE.Raycaster();
         const mouseRaycast = new THREE.Vector2();
         mouseRaycast.x = (e.clientX / window.innerWidth) * 2 - 1;
         mouseRaycast.y = -(e.clientY / window.innerHeight) * 2 + 1;
         raycaster.setFromCamera(mouseRaycast, MAIN.render.camera);
         const intersects = raycaster.intersectObjects(MAIN.render.scene.children);
         if(intersects[0]){
           const normalizedCords = {x:Math.floor(intersects[0].point.x),y:Math.floor(intersects[0].point.y),z:Math.floor(intersects[0].point.z)}





           const meshIndex = normalizedCords.z*100 + normalizedCords.x;

           let startIndex = 0;
           let uvStartIndex = 0;
           function findStartIndex(){
             console.time("findStartIndex");
             for(let i = 0;i<meshIndex;i++){
               startIndex += meshes[i].geometry.attributes.position.count*meshes[i].geometry.attributes.position.itemSize;
               uvStartIndex += meshes[i].geometry.attributes.uv.count*meshes[i].geometry.attributes.uv.itemSize;
             };
             console.timeEnd("findStartIndex");

           };
           findStartIndex();

           let new_position_array,new_normal_array,new_uv_array;

           function copyArrays(){
             console.time("copyArrays");
             new_position_array = Array.from(chunk.geometry.attributes.position.array);
             new_normal_array = Array.from(chunk.geometry.attributes.normal.array);
             new_uv_array = Array.from(chunk.geometry.attributes.uv.array);
             console.timeEnd("copyArrays");

           };
           copyArrays();


           function spliceArrays(){
             console.time("spliceArrays");
             new_position_array.splice(startIndex,meshes[meshIndex].geometry.attributes.position.count*meshes[meshIndex].geometry.attributes.position.itemSize);
             new_normal_array.splice(startIndex,meshes[meshIndex].geometry.attributes.normal.count*meshes[meshIndex].geometry.attributes.normal.itemSize);
             new_uv_array.splice(uvStartIndex,meshes[meshIndex].geometry.attributes.uv.count*meshes[meshIndex].geometry.attributes.uv.itemSize);
             console.timeEnd("spliceArrays");

           }
           spliceArrays();

           function applyAttributes(){
             console.time("applyAttributes");

             const geometry = new THREE.BufferGeometry;
             geometry.setAttribute('position',new THREE.BufferAttribute( new Float32Array(new_position_array), 3 ));
             geometry.setAttribute('normal',new THREE.BufferAttribute( new Float32Array(new_normal_array), 3 ));
             geometry.setAttribute('uv',new THREE.BufferAttribute( new Float32Array(new_uv_array), 2 ));
             chunk.geometry = geometry;
             console.timeEnd("applyAttributes");

           }
           applyAttributes();






           // console.log();


           // const new_geometry = new THREE.BufferGeometry();
           // // create a simple square shape. We duplicate the top left and bottom right
           // // vertices because each vertex needs to appear once per triangle.

           // // const new_vertexShadow_array = Array.from(mesh.geometry.attributes.ver.array);
           //
           // const index =  normalizedCords.z*2 + normalizedCords.x;
           //
           //  meshes.splice(index,1)
           //  const geometries = []
           //  meshes.forEach((mesh, i) => {
           //    geometries.push(mesh.geometry.clone());
           //  });
           //
           //
           //
           //
           //  mesh.geometry = BufferGeometryUtils.mergeBufferGeometries( geometries );





         };
       });



      const controls = new OrbitControls( MAIN.render.camera, MAIN.render.renderer.domElement );
      MAIN.render.camera.position.set(10,10,10)
      MAIN.render.camera.lookAt(0,0,0);

      MAIN.render.render();

    });





  </script>
</html>
