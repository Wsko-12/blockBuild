<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>all game blocks</title>
    <link rel="stylesheet" href="styles/common.css">

    <link rel="stylesheet" href="styles/gameInterface.css">
  </head>
  <body style="position:fixed;width:100vw;height:100vh;margin:0">
    <section id="render" class="fullscreen">

    </section>
    <!-- <canvas id="canvas" style="position:fixed;left:50vw;border:1px solid black" width="16" height="16"></canvas> -->

  </body>
  <script type="module">
    import * as THREE from './ThreeJsLib/build/three.module.js';
    import {MAIN} from './scripts/main.js';
    import {TEXTURES_BASE} from './scripts/modules/bases/textures_base.js';
    import {MESHES_BASE} from './scripts/modules/bases/meshes_base.js';
    import {BLOCKS_BASE} from './scripts/modules/bases/blocks_base.js';
    import {OrbitControls} from './ThreeJsLib/examples/jsm/controls/OrbitControls.js';
    import { BufferGeometryUtils } from './ThreeJsLib/examples/jsm/utils/BufferGeometryUtils.js';



    const geomJSON =     {
        	"metadata": {
        		"version": 4.5,
        		"type": "BufferGeometry",
        		"generator": "BufferGeometry.toJSON"
        	},
        	"uuid": "67E7D0B7-E734-4974-BC2F-515D6E28191E",
        	"type": "BufferGeometry",
        	"data": {
        		"attributes": {
        			"position": {
        				"itemSize": 3,
        				"type": "Float32Array",
        				"array": [-0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,0.5,-0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,-0.5,0.5,-0.5,0.5,0.5,0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5],
        				"normalized": false
        			},
        			"normal": {
        				"itemSize": 3,
        				"type": "Float32Array",
        				"array": [0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0],
        				"normalized": false
        			},
        			"uv": {
        				"itemSize": 2,
        				"type": "Float32Array",
        				"array": [1.0,0,0,0,0,1.0,1.0,0,0,1.0,1.0,1.0,1.0,0,0,0,0,1.0,1.0,0,0,1.0,1.0,1.0,0,1.0,1.0,1.0,1.0,0,0,1.0,1.0,0,0,0,0,1.0,1.0,1.0,1.0,0,0,1.0,1.0,0,0,0,1.0,1.0,0,0,0,1.0,1.0,1.0,1.0,0,0,0,1.0,1.0,1.0,0,0,0,1.0,1.0,0,0,0,1.0],
        				"normalized": false
        			}
        		},
        		"index": {
        			"type": "Uint16Array",
        			"array": [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35]
        		},
        		"boundingSphere": {
        			"center": [0,0,0],
        			"radius": 0.8660254037844386
        		}
        	}
        }





const loader = new THREE.BufferGeometryLoader();


const BOXgeometry =  loader.parse(geomJSON);



    MAIN.render.init();

    TEXTURES_BASE.init().then(result => {
      MESHES_BASE.init();
      BLOCKS_BASE.init();


      // for(let x = 0;x<100;x++){
      //    for(let z = 0;z<100;z++){
      //      const mesh_1 = MESHES_BASE.getMesh('ground');
      //      mesh_1.position.set(x,0,z);
      //      MAIN.render.scene.add(mesh_1)
      //    };
      //  };
      // const mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1),MESHES_BASE.getMesh('grass').material[0])
      //  MAIN.render.scene.add(mesh);
      //



       // merged
      const geometries = [];
      const meshes = []

      const chunkGeometry = {
        meshes:[],
        position:[],
        normal:[],
        uv:[],
      };
      const hitBoxes = new THREE.Group();
      const map = [];
      let startIndex = 0;
      let countIndex = 0;
      for(let x = 0;x<32;x++){
        map[x] = [];
        for(let z = 0;z<32;z++){
          map[x][z] = [];
          for(let y =0;y<32;y++){
            const geometry = loader.parse(geomJSON);
            const mesh = new THREE.Mesh(geometry,MESHES_BASE.getMesh('grass').material[0]);
            const hitBox = new THREE.Mesh(geometry);
            hitBoxes.add(hitBox);
            hitBox.userData.mesh = mesh;
            map[x][z][y] = mesh;
            chunkGeometry.meshes.push(mesh);
            mesh.geometry.translate(x+0.5,y+0.5,z+0.5);
            geometries.push(mesh.geometry.clone());
          };
        };
      };







			const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries( geometries,true );
      const chunk = new THREE.Mesh( mergedGeometry, new THREE.MeshBasicMaterial({map:MESHES_BASE.getMesh('grass').material[2].map}));
      // console.log(chunk)
    	 MAIN.render.scene.add(chunk);



       for(let i=0;i<chunk.geometry.attributes.position.array.length;i++){
         chunkGeometry.position.push(chunk.geometry.attributes.position.array[i]);
       };

       for(let i=0;i<chunk.geometry.attributes.normal.array.length;i++){
         chunkGeometry.normal.push(chunk.geometry.attributes.normal.array[i]);
       };

       for(let i=0;i<chunk.geometry.attributes.uv.array.length;i++){
         chunkGeometry.uv.push(chunk.geometry.attributes.uv.array[i]);
       };



       document.body.addEventListener('click',function(e){
           const raycaster = new THREE.Raycaster();
         const mouseRaycast = new THREE.Vector2();
         mouseRaycast.x = (e.clientX / window.innerWidth) * 2 - 1;
         mouseRaycast.y = -(e.clientY / window.innerHeight) * 2 + 1;
         raycaster.setFromCamera(mouseRaycast, MAIN.render.camera);
         const intersects = raycaster.intersectObjects(hitBoxes.children);
         if(intersects[0]){

              console.time("indexOf");
           const meshIndex = chunkGeometry.meshes.indexOf(intersects[0].object.userData.mesh);
           hitBoxes.remove(intersects[0].object)


           console.timeEnd("indexOf");


           if(meshIndex >= 0){
             let startIndex = 0;
             let uvStartIndex = 0;
             function findStartIndex(){
               console.time("findStartIndex");
               for(let i = 0;i<meshIndex;i++){
                 startIndex += chunkGeometry.meshes[i].geometry.attributes.position.count*chunkGeometry.meshes[i].geometry.attributes.position.itemSize;
                 uvStartIndex += chunkGeometry.meshes[i].geometry.attributes.uv.count*chunkGeometry.meshes[i].geometry.attributes.uv.itemSize;
               };
               console.timeEnd("findStartIndex");

             };
             findStartIndex();

             function spliceArrays(){
               console.time("spliceArrays");
               chunkGeometry.position.splice(startIndex,chunkGeometry.meshes[meshIndex].geometry.attributes.position.count*chunkGeometry.meshes[meshIndex].geometry.attributes.position.itemSize);
               chunkGeometry.normal.splice(startIndex,chunkGeometry.meshes[meshIndex].geometry.attributes.normal.count*chunkGeometry.meshes[meshIndex].geometry.attributes.normal.itemSize);
               chunkGeometry.uv.splice(uvStartIndex,chunkGeometry.meshes[meshIndex].geometry.attributes.uv.count*chunkGeometry.meshes[meshIndex].geometry.attributes.uv.itemSize);

               chunkGeometry.meshes.splice(meshIndex,1);
               console.timeEnd("spliceArrays");

             }
             spliceArrays();



             function applyAttributes(){
               console.time("applyAttributes");

               const geometry = new THREE.BufferGeometry;
               geometry.setAttribute('position',new THREE.BufferAttribute( new Float32Array( chunkGeometry.position), 3 ));
               geometry.setAttribute('normal',new THREE.BufferAttribute( new Float32Array(chunkGeometry.normal), 3 ));
               geometry.setAttribute('uv',new THREE.BufferAttribute( new Float32Array( chunkGeometry.uv), 2 ));
               chunk.geometry = geometry;
               console.timeEnd("applyAttributes");

             }
             applyAttributes();

           };






           // const meshIndex = normalizedCords.x + normalizedCords.z + normalizedCords.y;
           //
           // let startIndex = 0;
           // let uvStartIndex = 0;
           // function findStartIndex(){
           //   // console.time("findStartIndex");
           //   for(let i = 0;i<meshIndex;i++){
           //     startIndex += meshes[i].geometry.attributes.position.count*meshes[i].geometry.attributes.position.itemSize;
           //     uvStartIndex += meshes[i].geometry.attributes.uv.count*meshes[i].geometry.attributes.uv.itemSize;
           //   };
           //   // console.timeEnd("findStartIndex");
           //
           // };
           // findStartIndex();
           //
           // let new_position_array = [];
           // let new_normal_array = [];
           // let new_uv_array = [];
           //
           // function copyArrays(){
           //   console.time("copyArrays");
           //
           //   //~2300ms
           //   // new_position_array = [...chunk.geometry.attributes.position.array];
           //   // new_normal_array = [...chunk.geometry.attributes.normal.array];
           //   // new_uv_array = [...chunk.geometry.attributes.uv.array];
           //
           //
           //
           //
           //   // ~350ms
           //   // let posLength = chunk.geometry.attributes.position.array.length;
           //   // let posIndex = 0
           //   // while (posIndex < posLength) {
           //   //     new_position_array.push(chunk.geometry.attributes.position.array[posIndex]);
           //   //     posIndex++;
           //   //  };
           //   //
           //   //  let normLength = chunk.geometry.attributes.normal.array.length;
           //   //  let normIndex = 0;
           //   //  while (normIndex < normLength) {
           //   //      new_normal_array.push(chunk.geometry.attributes.normal.array[normIndex]);
           //   //      normIndex++;
           //   //   };
           //   //
           //   //   let uvLength = chunk.geometry.attributes.uv.array.length;
           //   //   let uvIndex = 0;
           //   //   while (uvIndex < uvLength) {
           //   //       new_uv_array.push(chunk.geometry.attributes.uv.array[uvIndex]);
           //   //       uvIndex++;
           //   //    };
           //
           //
           //
           //   //~10000ms
           //   // Object.assign(new_position_array,chunk.geometry.attributes.position.array);
           //   //
           //   // Object.assign(new_normal_array,chunk.geometry.attributes.normal.array);
           //   //
           //   // Object.assign(new_uv_array,chunk.geometry.attributes.uv.array);
           //
           //
           //
           //   // вообще повис
           //   // let posIndex = chunk.geometry.attributes.position.array.length-1;
           //   // while (posIndex >= 0) {
           //   //     new_position_array.unshift(chunk.geometry.attributes.position.array[posIndex]);
           //   //     posIndex--;
           //   //  };
           //   //
           //   //  let normIndex = chunk.geometry.attributes.normal.array.length-1;
           //   //  while (normIndex >= 0) {
           //   //      new_normal_array.unshift(chunk.geometry.attributes.normal.array[normIndex]);
           //   //      normIndex--;
           //   //   };
           //   //
           //   //   let uvIndex = chunk.geometry.attributes.uv.array.length-1;
           //   //   while (uvIndex >= 0) {
           //   //       new_uv_array.unshift(chunk.geometry.attributes.uv.array[uvIndex]);
           //   //       uvIndex--;
           //   //    };
           //
           //
           //    //~800ms
           //   // chunk.geometry.attributes.position.array.map((item) =>{
           //   //    new_position_array.push(item);
           //   // });
           //   // chunk.geometry.attributes.normal.array.map((item) => {
           //   //   new_normal_array.push(item);
           //   // });
           //   //
           //   // chunk.geometry.attributes.uv.array.map((item) => {
           //   //   new_uv_array.push(item);
           //   // });
           //
           //
           //
           //     //~350ms
           //  //  const posLength = chunk.geometry.attributes.position.array.length;
           //  //  for(let i=0;i<posLength;i++){
           //  //    new_position_array.push(chunk.geometry.attributes.position.array[i]);
           //  //  }
           //  //
           //  // const normLength = chunk.geometry.attributes.normal.array.length;
           //  //  for(let i=0;i<normLength;i++){
           //  //    new_normal_array.push(chunk.geometry.attributes.normal.array[i]);
           //  //  }
           //  //  const uvLength = chunk.geometry.attributes.uv.array.length;
           //  //  for(let i=0;i<uvLength;i++){
           //  //    new_uv_array.push(chunk.geometry.attributes.uv.array[i]);
           //  //  }
           //
           //
           //    // ~350ms
           //   for(let i=0;i<chunk.geometry.attributes.position.array.length;i++){
           //     new_position_array.push(chunk.geometry.attributes.position.array[i]);
           //   }
           //
           //   for(let i=0;i<chunk.geometry.attributes.normal.array.length;i++){
           //     new_normal_array.push(chunk.geometry.attributes.normal.array[i]);
           //   }
           //
           //   for(let i=0;i<chunk.geometry.attributes.uv.array.length;i++){
           //     new_uv_array.push(chunk.geometry.attributes.uv.array[i]);
           //   }
           //
           //
           //
           //
           //
           //
           //
           //   //~500ms
           //   // chunk.geometry.attributes.position.array.forEach((item, i) => {
           //   //   new_position_array.push(item);
           //   // });
           //   //
           //   // chunk.geometry.attributes.normal.array.forEach((item, i) => {
           //   //   new_normal_array.push(item)
           //   // });
           //   //
           //   // chunk.geometry.attributes.uv.array.forEach((item, i) => {
           //   //   new_uv_array.push(item)
           //   // });
           //
           //
           //   //~850ms
           //   // new_position_array = Array.from(chunk.geometry.attributes.position.array);
           //   // new_normal_array = Array.from(chunk.geometry.attributes.normal.array);
           //   // new_uv_array = Array.from(chunk.geometry.attributes.uv.array);
           //   console.timeEnd("copyArrays");
           //
           // };
           // copyArrays();
           //
           //
           // function spliceArrays(){
           //   // console.time("spliceArrays");
           //   new_position_array.splice(startIndex,meshes[meshIndex].geometry.attributes.position.count*meshes[meshIndex].geometry.attributes.position.itemSize);
           //   new_normal_array.splice(startIndex,meshes[meshIndex].geometry.attributes.normal.count*meshes[meshIndex].geometry.attributes.normal.itemSize);
           //   new_uv_array.splice(uvStartIndex,meshes[meshIndex].geometry.attributes.uv.count*meshes[meshIndex].geometry.attributes.uv.itemSize);
           //   // console.timeEnd("spliceArrays");
           //
           // }
           // spliceArrays();
           //
           // function applyAttributes(){
           //   // console.time("applyAttributes");
           //
           //   const geometry = new THREE.BufferGeometry;
           //   geometry.setAttribute('position',new THREE.BufferAttribute( new Float32Array(new_position_array), 3 ));
           //   geometry.setAttribute('normal',new THREE.BufferAttribute( new Float32Array(new_normal_array), 3 ));
           //   geometry.setAttribute('uv',new THREE.BufferAttribute( new Float32Array(new_uv_array), 2 ));
           //   chunk.geometry = geometry;
           //   // console.timeEnd("applyAttributes");
           //
           // }
           // applyAttributes();






           // console.log();


           // const new_geometry = new THREE.BufferGeometry();
           // // create a simple square shape. We duplicate the top left and bottom right
           // // vertices because each vertex needs to appear once per triangle.

           // // const new_vertexShadow_array = Array.from(mesh.geometry.attributes.ver.array);
           //
           // const index =  normalizedCords.z*2 + normalizedCords.x;
           //
           //  meshes.splice(index,1)
           //  const geometries = []
           //  meshes.forEach((mesh, i) => {
           //    geometries.push(mesh.geometry.clone());
           //  });
           //
           //
           //
           //
           //  mesh.geometry = BufferGeometryUtils.mergeBufferGeometries( geometries );





         };
       });



      const controls = new OrbitControls( MAIN.render.camera, MAIN.render.renderer.domElement );
      MAIN.render.camera.position.set(10,10,10)
      MAIN.render.camera.lookAt(0,0,0);

      MAIN.render.render();

    });





  </script>
</html>
