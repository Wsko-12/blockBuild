<!DOCTYPE html>
<html lang="ru" dir="ltr">

<head>
  <meta charset="utf-8">
  <title>softShadow</title>
</head>

<body style="position:fixed;width:100vw;height:100vh;margin:0">

</body>
<script type="module">
  import * as THREE from './ThreeJsLib/build/three.module.js';
  import {
    MAIN
  } from './scripts/main.js';
  import {
    TEXTURES_BASE
  } from './scripts/modules/bases/textures_base.js';
  import {
    MESHES_BASE
  } from './scripts/modules/bases/meshes_base.js';
  import {
    BLOCKS_BASE
  } from './scripts/modules/bases/blocks_base.js';
  import {
    BLOCKS_MODULE
  } from './blocks0.0.1.js';
  MAIN.render.init();

  TEXTURES_BASE.init().then(result => {
    MESHES_BASE.init();
    BLOCKS_BASE.init();

    const size = {
      width: 24,
      height: 6,
    }


    const map = [];
    document.addEventListener('keydown',function(e){
      if(e.key === 'r'){
        console.log('r')
        map.updateAmbientLight();
      }
    })

    map.addBlock = function(block) {
      const position = block.position;
      map[position.x][position.z][position.y].contant = block;
      block.mapCeil = map[position.x][position.z][position.y];
      block.addMeshToScene();
    };

    map.updateAllInvisibleFaces = function() {
      console.time('updateAllInvisibleFaces');
      for (let x = 0; x < size.width; x++) {
        for (let z = 0; z < size.width; z++) {
          for (let y = 0; y < size.height; y++) {
            if (map[x][z][y].contant) {
              map[x][z][y].contant.updateInvisibleFaces();
            };
          };
        };
      };
      console.timeEnd('updateAllInvisibleFaces');
    };

    //!!!!!!!
    map.onUpdateAmbientLight = false;
    map.updateAmbientLight = function(helpers) {
      if(!map.onUpdateAmbientLight){
        console.log('updateAmbientLight');
        map.onUpdateAmbientLight = true;
        const updateID = Math.random();
        const airBlocks = [];
        const blocks = [];



        console.time('updateAmbientLight_blockSort');
        for (let x = 0; x < size.width; x++) {
          for (let z = 0; z < size.width; z++) {
            let lightValue = 15;
            for (let y = size.height - 1; y >= 0; y--) {
              const mapCeil = map[x][z][y];
              mapCeil.lightUpdateId = updateID;
              if (mapCeil.contant != null) {
                lightValue = 1;
                blocks.push(mapCeil.contant);
              } else {
                airBlocks.push(mapCeil);
              }
              mapCeil.lightValue = lightValue;
            };
          };
        };
        console.timeEnd('updateAmbientLight_blockSort');

        {

        }


        let updatedMapCeilIndex = 0;
        let updatedBlockIndex = 0;

        // function updateMapCeils(){
        //   for(let i = 0;i<10;i++){
        //     if(updatedMapCeilIndex < airBlocks.length){
        //        airBlocks[updatedMapCeilIndex].updateLight(helpers);
        //     }
        //      updatedMapCeilIndex++;
        //      if(updatedMapCeilIndex === airBlocks.length){
        //        updateBlocks();
        //      }
        //   };
        //   if(updatedMapCeilIndex < airBlocks.length){
        //     setTimeout(function(){
        //       updateMapCeils();
        //     })
        //   };
        // };
        // updateMapCeils();

        console.time('updateAmbientLight_airBlocks_updateLight');
        airBlocks.forEach((mapCeil, i) => {
          mapCeil.updateLight();
        });
        console.timeEnd('updateAmbientLight_airBlocks_updateLight');



        blocks.forEach((thisBlock, i) => {
          let lastBlock = false;
          if(i === blocks.length-1){
            lastBlock=true;
          }
          thisBlock.updateShadow(lastBlock,map);
        });

        // updateBlocks();
        //
        // function updateBlocks(){
        //   for(let i = 0;i<10;i++){
        //     if(updatedBlockIndex < blocks.length){
        //       let lastBlock = false;
        //       if(updatedBlockIndex === blocks.length - 1){
        //         lastBlock = true;
        //       };
        //       blocks[updatedBlockIndex].updateShadow(lastBlock,map);
        //     };
        //     updatedBlockIndex++;
        //   };
        //   if(updatedBlockIndex < blocks.length){
        //     setTimeout(function(){
        //       updateBlocks();
        //     })
        //   };
        // };
      }else{
        console.log('onUpdate!');
      }
      setTimeout(function(){
        // map.updateAmbientLight();
      },2000)
};

    map.initMapCeils = function() {
      console.time('initMapCeils');

      for (let x = 0; x < size.width; x++) {
        for (let z = 0; z < size.width; z++) {
          for (let y = 0; y < size.height; y++) {
            map[x][z][y].init();
          };
        };
      };
      console.timeEnd('initMapCeils');
    };

    function mapCeil(x, y, z) {
      const self = {};
      self.shadowsDate = {
        updated:false,
      };
      self.position = {
        x,
        y,
        z,
      };
      //!!!!!
      self.findCrossNeighbors = function() {
        const crossNeighborsIndex = [
          [this.position.x + 1, this.position.y, this.position.z, 'e'],
          [this.position.x - 1, this.position.y, this.position.z, 'w'],
          [this.position.x, this.position.y + 1, this.position.z, 't'],
          [this.position.x, this.position.y - 1, this.position.z, 'b'],
          [this.position.x, this.position.y, this.position.z + 1, 's'],
          [this.position.x, this.position.y, this.position.z - 1, 'n'],
        ];

        this.crossNeighbors = [null, null, null, null, null, null];
        crossNeighborsIndex.forEach((item, i) => {
          const x = item[0];
          const y = item[1];
          const z = item[2];
          //если вышли за край карты
          if (x >= 0 && x < size.width && y >= 0 && y < size.height && z >= 0 && z < size.width) {
            this.crossNeighbors[i] = map[x][z][y];
          };
        });
      };

      self.findAroundNeighbors = function(radius, helpers) {
        const aroundNeighbors = [];
        for (let yI = radius; yI >= 0 - radius; yI--) {
          for (let zI = 0 - radius; zI <= radius; zI++) {
            for (let xI = 0 - radius; xI <= radius; xI++) {
              const neighbor = {
                x: this.position.x + xI,
                y: this.position.y + yI,
                z: this.position.z + zI,
              };

              //выход за пределы карты
              if (neighbor.x >= 0 && neighbor.x < size.width && neighbor.y >= 0 && neighbor.y < size.height && neighbor.z >= 0 && neighbor.z < size.width) {

                if (xI === 0 && zI === 0 && yI === 0) {
                  //если он сам
                } else {
                  if (helpers) {
                    if (!MAIN.render.config.helpers.neighbors) {
                      MAIN.render.config.helpers.neighbors = new THREE.Group();
                      MAIN.render.scene.add(MAIN.render.config.helpers.neighbors);
                    };
                    const geom = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                    const material = new THREE.MeshBasicMaterial({
                      color: 0x5fb942,
                      transparent: true,
                      opacity: 0.5,
                    });


                    const mesh = new THREE.Mesh(geom, material);
                    mesh.position.x = neighbor.x;
                    mesh.position.y = neighbor.y;
                    mesh.position.z = neighbor.z;

                    MAIN.render.config.helpers.neighbors.add(mesh);
                  };
                  aroundNeighbors.push(map[neighbor.x][neighbor.z][neighbor.y]);
                }
              } else {
                aroundNeighbors.push(null);
              };
            };
          };
        };
        return aroundNeighbors;
      };


      self.findCloseNeighbors = function() {
        this.closeNeighbors = this.findAroundNeighbors(1);
      };

      //!!!!!!!
      self.findNeighborsBySide = function(helpers) {
        this.neighborsBySide = [];
        const neighbors = this.closeNeighbors;

        //
        const east = [];
        east.push(neighbors[8]);
        east.push(neighbors[5]);
        east.push(neighbors[2]);

        east.push(neighbors[11]);
        east.push(neighbors[19]);
        east.push(neighbors[22]);

        east.push(neighbors[25]);
        east.push(neighbors[16]);
        east.push(neighbors[13]);
        this.neighborsBySide.push(east);





        const west = [];
        west.push(neighbors[0]);
        west.push(neighbors[3]);
        west.push(neighbors[6]);

        west.push(neighbors[14]);
        west.push(neighbors[23]);
        west.push(neighbors[20]);

        west.push(neighbors[17]);
        west.push(neighbors[9]);
        west.push(neighbors[12]);
        this.neighborsBySide.push(west);

        const top = [];
        top.push(neighbors[0]);
        top.push(neighbors[1]);
        top.push(neighbors[2]);

        top.push(neighbors[5]);
        top.push(neighbors[8]);
        top.push(neighbors[7]);

        top.push(neighbors[6]);
        top.push(neighbors[3]);
        top.push(neighbors[4]);
        this.neighborsBySide.push(top);

        const bottom = [];
        bottom.push(neighbors[23]);
        bottom.push(neighbors[24]);
        bottom.push(neighbors[25]);

        bottom.push(neighbors[22]);
        bottom.push(neighbors[19]);
        bottom.push(neighbors[18]);

        bottom.push(neighbors[17]);
        bottom.push(neighbors[20]);
        bottom.push(neighbors[21]);
        this.neighborsBySide.push(bottom);

        const south = [];
        south.push(neighbors[6]);
        south.push(neighbors[7]);
        south.push(neighbors[8]);

        south.push(neighbors[16]);
        south.push(neighbors[25]);
        south.push(neighbors[24]);

        south.push(neighbors[23]);
        south.push(neighbors[14]);
        south.push(neighbors[15]);
        this.neighborsBySide.push(south);


        const north = [];
        north.push(neighbors[2]);
        north.push(neighbors[1]);
        north.push(neighbors[0]);

        north.push(neighbors[9]);
        north.push(neighbors[17]);
        north.push(neighbors[18]);

        north.push(neighbors[19]);
        north.push(neighbors[11]);
        north.push(neighbors[10]);
        this.neighborsBySide.push(north);


        if (helpers) {
          if (!MAIN.render.config.helpers.neighbors) {
            MAIN.render.config.helpers.neighbors = new THREE.Group();
            MAIN.render.scene.add(MAIN.render.config.helpers.neighbors);
          };
          south.forEach((item, i) => {
            if (item != null) {
              const geom = new THREE.BoxGeometry(0.2, 0.2, 0.2);
              const material = new THREE.MeshBasicMaterial({
                color: 0xe7e527,
                transparent: true,
                opacity: 0.5,
              });


              const mesh = new THREE.Mesh(geom, material);
              mesh.position.x = item.position.x;
              mesh.position.y = item.position.y;
              mesh.position.z = item.position.z;

              MAIN.render.config.helpers.neighbors.add(mesh);
            };
          });
        };
      };



      self.init = function() {
        this.findCrossNeighbors();
        this.findCloseNeighbors();
        //!!!!!!
        this.findNeighborsBySide();
      };



      //!!!!!!!
      self.updateLight = function(helpers) {
        if (helpers) {
          if (!MAIN.render.config.helpers.lightHelpers) {
            MAIN.render.config.helpers.lightHelpers = new THREE.Group();
            MAIN.render.scene.add(MAIN.render.config.helpers.lightHelpers);
          };
          const geom = new THREE.BoxGeometry(0.15, 0.15, 0.15);
          const material = new THREE.MeshBasicMaterial({
            color: `rgb(${Math.round(255*this.lightValue/15)},${Math.round(255*this.lightValue/15)},${Math.round(255*this.lightValue/15)})`,
            transparent: true,
            opacity: 1,
          });


          const mesh = new THREE.Mesh(geom, material);
          mesh.position.x = this.position.x;
          mesh.position.y = this.position.y;
          mesh.position.z = this.position.z;

          MAIN.render.config.helpers.lightHelpers.add(mesh);
        }
        this.crossNeighbors.forEach((neighbor, i) => {
          //если не вышли за пределы карты
          if (neighbor != null) {
            if (neighbor.contant) {
              //если сосед блок
              // neighbor.contant.updateShadow();
            } else {
              //если нет, то
              if (neighbor.lightValue < this.lightValue - 1) {
                neighbor.lightValue = this.lightValue - 1;
                neighbor.updateLight(helpers);
              };
            };
          };
        });
      };

      self.contant = null;
      return self;
    };

    function initMap() {
      console.time('initMap');
      //init map array
      for (let x = 0; x < size.width; x++) {
        map.push([]);
        for (let z = 0; z < size.width; z++) {
          map[x].push([]);
          for (let y = 0; y < size.height; y++) {
            map[x][z].push([]);
            map[x][z][y] = mapCeil(x, y, z);
          };
        };
      };
      console.timeEnd('initMap');
      map.initMapCeils();
    };



    initMap();



    // let block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:1,y:1,z:1});
    // map.addBlock(block);
    //
    // block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:1,y:1,z:0});
    // map.addBlock(block);
    //
    // block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:0,y:1,z:1});
    // map.addBlock(block);
    // block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:0,y:1,z:0});
    // map.addBlock(block);
    // block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:2,y:1,z:0});
    // map.addBlock(block);
    // block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:2,y:0,z:0});
    // map.addBlock(block);
    //
    // block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:2,y:0,z:2});
    // map.addBlock(block);
    //
    // block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:2,y:0,z:1});
    // map.addBlock(block);
    //
    // block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:1,y:0,z:2});
    // map.addBlock(block);








    console.time('addingBlocks')
    for (let x = 0; x < size.width; x++) {
      for (let z = 0; z < size.width; z++) {
        for (let y = 0; y < size.height-1; y++) {
          if (Math.random() > 0.3) {
            let block = BLOCKS_MODULE.getBlock('test');
            block.setPosition({
              x,
              y,
              z
            });
            map.addBlock(block);
          }
        };
      };
    };
    console.timeEnd('addingBlocks')
    map.updateAllInvisibleFaces();







    // for(let x=1;x<size.width;x++){
    //   let block = BLOCKS_MODULE.getBlock('test');
    //   block.setPosition({x,y:2,z:0});
    //   map.addBlock(block);
    //   block = BLOCKS_MODULE.getBlock('test');
    //   block.setPosition({x,y:1,z:1});
    //   map.addBlock(block);
    // }
    // let block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:1,y:1,z:1});
    // map.addBlock(block);
    // block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:0,y:2,z:1});
    // map.addBlock(block);
    // block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:1,y:2,z:0});
    // map.addBlock(block);
    // block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:0,y:2,z:0});
    // map.addBlock(block);
    // let block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:0,y:0,z:0});
    // map.addBlock(block);
    // let block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:0,y:0,z:1});
    // map.addBlock(block);
    // let block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:0,y:0,z:2});
    // map.addBlock(block);
    // let block = BLOCKS_MODULE.getBlock('test');
    // block.setPosition({x:1,y:0,z:});
    // map.addBlock(block);





    // map[1][1][1].findAroundNeighbors(1,true);
    // map[1][1][1].findNeighborsBySide(true);





    setTimeout(function() {
      map.updateAmbientLight(false);
    });



  });
</script>

</html>
